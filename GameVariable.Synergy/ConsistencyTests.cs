using System.Reflection;
using System.Runtime.InteropServices;
using System.Runtime.Serialization;
using Variable.Bounded;
using Variable.Regen;
using Xunit;

namespace GameVariable.Synergy;

public class ConsistencyTests
{
    // List of assemblies to check
    private static readonly Assembly[] TargetAssemblies = new[]
    {
        typeof(BoundedFloat).Assembly, // Variable.Bounded
        typeof(Variable.Core.MathConstants).Assembly, // Variable.Core
        // typeof(Variable.Experience.ExperienceInt).Assembly, // Variable.Experience
        // typeof(Variable.Input.InputRingBuffer).Assembly, // Variable.Input
        // typeof(Variable.Inventory.InventoryLogic).Assembly, // Variable.Inventory
        // typeof(RegenFloat).Assembly, // Variable.Regen
        // typeof(Variable.Reservoir.ReservoirFloat).Assembly, // Variable.Reservoir
        // typeof(Variable.RPG.RpgStat).Assembly, // Variable.RPG
        // typeof(Variable.Timer.Timer).Assembly, // Variable.Timer
        typeof(GameVariable.Intent.IntentState).Assembly // GameVariable.Intent
    };

    [Fact]
    public void LayerA_Structs_MustBeSerializable_And_SequentialLayout()
    {
        foreach (var assembly in TargetAssemblies)
        {
            var structs = assembly.GetTypes()
                .Where(t => t.IsValueType && !t.IsEnum && !t.IsNestedPrivate && !t.Name.EndsWith("Tests") && !t.Name.StartsWith("<"))
                .ToList();

            foreach (var type in structs)
            {
                // Skip compiler generated types or types that are clearly not data structs (e.g. state machines might differ but let's see)
                if (type.GetCustomAttribute<System.Runtime.CompilerServices.CompilerGeneratedAttribute>() != null)
                    continue;

                // GameVariable.Intent.IntentState is an exception mentioned in memory/guidelines?
                // "GameVariable.Intent.IntentState is an autogenerated struct... serving as a permitted exception"
                if (type.FullName == "GameVariable.Intent.IntentState")
                    continue;

                // Variable.RPG.RpgStatSheet is an unsafe struct managing unmanaged memory, so it cannot be Serializable in the standard way.
                if (type.FullName == "Variable.RPG.RpgStatSheet")
                    continue;

                // Also skip enumerators
                if (type.GetInterfaces().Any(i => i.Name.Contains("IEnumerator")))
                    continue;

                Assert.True(type.IsSerializable, $"{type.FullName} should be [Serializable]");
                Assert.True(type.IsLayoutSequential, $"{type.FullName} should be [StructLayout(LayoutKind.Sequential)]");
            }
        }
    }

    [Fact]
    public void LayerB_LogicClasses_MustBeStatic()
    {
        foreach (var assembly in TargetAssemblies)
        {
            var logicClasses = assembly.GetTypes()
                .Where(t => t.Name.EndsWith("Logic") && t.IsClass)
                .ToList();

            foreach (var type in logicClasses)
            {
                Assert.True(type.IsAbstract && type.IsSealed, $"{type.FullName} must be static (abstract sealed).");
            }
        }
    }

    [Fact]
    public void LayerB_LogicMethods_MustReturnVoidOrBool()
    {
        foreach (var assembly in TargetAssemblies)
        {
            var logicClasses = assembly.GetTypes()
                .Where(t => t.Name.EndsWith("Logic") && t.IsClass)
                .ToList();

            foreach (var type in logicClasses)
            {
                var methods = type.GetMethods(BindingFlags.Public | BindingFlags.Static | BindingFlags.DeclaredOnly)
                    .Where(m => !m.IsSpecialName); // Exclude property accessors if any

                foreach (var method in methods)
                {
                    var returnType = method.ReturnType;
                    bool isValid = returnType == typeof(void) || returnType == typeof(bool);
                    Assert.True(isValid, $"{type.FullName}.{method.Name} returns {returnType.Name}. Logic methods must return void or bool.");
                }
            }
        }
    }

    [Fact]
    public void LayerB_LogicMethods_MustNotUseRefParameters()
    {
        foreach (var assembly in TargetAssemblies)
        {
            var logicClasses = assembly.GetTypes()
                .Where(t => t.Name.EndsWith("Logic") && t.IsClass)
                .ToList();

            foreach (var type in logicClasses)
            {
                var methods = type.GetMethods(BindingFlags.Public | BindingFlags.Static | BindingFlags.DeclaredOnly);

                foreach (var method in methods)
                {
                    foreach (var param in method.GetParameters())
                    {
                        // out parameters are ByRef, so we check if it is IsOut
                        if (param.ParameterType.IsByRef)
                        {
                            Assert.True(param.IsOut, $"{type.FullName}.{method.Name} parameter '{param.Name}' is 'ref'. Logic methods must not use 'ref' (only 'out' allowed).");
                        }
                    }
                }
            }
        }
    }
}
