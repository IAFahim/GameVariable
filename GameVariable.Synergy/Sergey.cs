using System.Reflection;
using System.Runtime.InteropServices;
using System.Runtime.CompilerServices;
using Xunit;

namespace GameVariable.Synergy;

public class Sergey
{
    // Whitelisted single letter variables
    private static readonly HashSet<string> AllowedSingleLetters = new() { "x", "y", "z", "r", "g", "b", "a" };

    private IEnumerable<Assembly> GetProjectAssemblies()
    {
        var references = Assembly.GetExecutingAssembly().GetReferencedAssemblies();
        foreach (var refName in references)
        {
            if (refName.Name != null &&
                (refName.Name.StartsWith("Variable.") || refName.Name.StartsWith("GameVariable."))
                && !refName.Name.EndsWith(".Tests")
                && !refName.Name.EndsWith(".Synergy")
                && !refName.Name.EndsWith(".Benchmarks"))
            {
                yield return Assembly.Load(refName);
            }
        }
    }

    [Fact]
    public void ValidateNamingConventions()
    {
        var errors = new List<string>();

        foreach (var asm in GetProjectAssemblies())
        {
            foreach (var type in asm.GetTypes())
            {
                if (!type.IsPublic) continue;
                if (IsAutogenerated(type)) continue;

                // Check Fields
                foreach (var field in type.GetFields(BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.Static | BindingFlags.DeclaredOnly))
                {
                    if (IsInvalidName(field.Name))
                        errors.Add($"Field '{field.Name}' in {type.FullName} violates naming convention.");
                }

                // Check Properties
                foreach (var prop in type.GetProperties(BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.Static | BindingFlags.DeclaredOnly))
                {
                    if (IsInvalidName(prop.Name))
                        errors.Add($"Property '{prop.Name}' in {type.FullName} violates naming convention.");
                }

                // Check Methods and Parameters
                foreach (var method in type.GetMethods(BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.Static | BindingFlags.DeclaredOnly))
                {
                    if (IsAutogenerated(method)) continue;

                    // Check Parameters
                    foreach (var param in method.GetParameters())
                    {
                        if (IsInvalidName(param.Name))
                             errors.Add($"Parameter '{param.Name}' in {type.FullName}.{method.Name} violates naming convention.");
                    }
                }
            }
        }

        Assert.Empty(errors);
    }

    private bool IsInvalidName(string? name)
    {
        if (string.IsNullOrEmpty(name)) return false;

        // Remove @ prefix for reserved keywords
        if (name.StartsWith("@")) name = name.Substring(1);

        // Remove backing field suffix
        if (name.Contains("<")) return false;

        // Single letter check
        if (name.Length == 1 && !AllowedSingleLetters.Contains(name.ToLower()))
        {
            return true;
        }

        // Hungarian notation check is skipped as it is prone to false positives without stricter rules.
        // We rely on the single letter check which is explicit.

        return false;
    }

    [Fact]
    public void ValidateLayerA_PureData()
    {
        var errors = new List<string>();
        foreach (var asm in GetProjectAssemblies())
        {
            // Layer A: Public structs in Variable.* namespaces, excluding Logic/Extensions classes.
            var structs = asm.GetTypes().Where(t => t.IsValueType && !t.IsEnum && !t.IsPrimitive && t.IsPublic && !t.IsNestedPrivate);

            foreach (var type in structs)
            {
                if (type.Name.EndsWith("Logic") || type.Name.EndsWith("Extensions")) continue;
                if (IsAutogenerated(type)) continue;
                if (type.FullName == "Variable.RPG.RpgStatSheet") continue;

                // Check [Serializable]
#pragma warning disable SYSLIB0050
                if (!type.IsSerializable)
                    errors.Add($"Data Struct {type.FullName} is not [Serializable].");
#pragma warning restore SYSLIB0050

                // Check [StructLayout(LayoutKind.Sequential)]
                if (type.StructLayoutAttribute?.Value != LayoutKind.Sequential)
                     errors.Add($"Data Struct {type.FullName} does not use [StructLayout(LayoutKind.Sequential)].");

                // Check for Logic methods
                foreach (var method in type.GetMethods(BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly))
                {
                    if (method.Name.StartsWith("get_") || method.Name.StartsWith("set_")) continue; // Properties
                    if (method.Name == "Equals" || method.Name == "GetHashCode" || method.Name == "ToString" || method.Name == "CompareTo" || method.Name == "Deconstruct" || method.Name == "TryFormat") continue;

                    // Allow operators
                    if (method.Name.StartsWith("op_")) continue;

                    errors.Add($"Data Struct {type.FullName} contains logic method '{method.Name}'. Only pure data allowed.");
                }
            }
        }
        Assert.Empty(errors);
    }

    [Fact]
    public void ValidateLayerB_PureLogic()
    {
        var errors = new List<string>();
        foreach (var asm in GetProjectAssemblies())
        {
            var logicClasses = asm.GetTypes().Where(t => t.Name.EndsWith("Logic") && t.IsClass && t.IsPublic);

            foreach (var type in logicClasses)
            {
                // Check Static Class
                if (!type.IsAbstract || !type.IsSealed)
                    errors.Add($"Logic Class {type.FullName} must be static.");

                // Check Stateless
                foreach (var field in type.GetFields(BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Static | BindingFlags.DeclaredOnly))
                {
                    if (!field.IsInitOnly && !field.IsLiteral)
                        errors.Add($"Logic Class {type.FullName} contains mutable static field '{field.Name}'. Must be stateless.");
                }

                // Check Methods return void or bool
                foreach (var method in type.GetMethods(BindingFlags.Public | BindingFlags.Static | BindingFlags.DeclaredOnly))
                {
                     if (method.Name.StartsWith("get_") || method.Name.StartsWith("set_")) continue;

                     if (method.ReturnType != typeof(void) && method.ReturnType != typeof(bool))
                     {
                         errors.Add($"Logic Method {type.FullName}.{method.Name} returns {method.ReturnType.Name}. Must return void or bool.");
                     }
                }
            }
        }
        Assert.Empty(errors);
    }

    private bool IsAutogenerated(Type type)
    {
        if (type.GetCustomAttribute<CompilerGeneratedAttribute>() != null) return true;
        if (type.FullName != null && type.FullName.Contains("IntentState")) return true;
        return false;
    }

    private bool IsAutogenerated(MethodInfo method)
    {
         if (method.GetCustomAttribute<CompilerGeneratedAttribute>() != null) return true;
         return false;
    }
}
