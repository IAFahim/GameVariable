using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using System.Runtime.InteropServices;
using Xunit;

namespace GameVariable.Synergy;

public class Sergey
{
    private static readonly string[] TargetAssemblies =
    {
        "Variable.Core",
        "Variable.Bounded",
        "Variable.Timer",
        "Variable.Inventory",
        "Variable.Experience",
        "Variable.Regen",
        "Variable.Reservoir",
        "Variable.Input",
        "Variable.RPG",
        "GameVariable.Intent"
    };

    private static IEnumerable<Assembly> GetProjectAssemblies()
    {
        var assemblies = AppDomain.CurrentDomain.GetAssemblies();
        foreach (var name in TargetAssemblies)
        {
            var asm = assemblies.FirstOrDefault(a => a.GetName().Name == name);
            if (asm != null)
            {
                yield return asm;
            }
            else
            {
                Assembly loaded = null;
                try
                {
                    loaded = Assembly.Load(name);
                }
                catch
                {
                    // Fail or ignore? For now ignore, but list it.
                }

                if (loaded != null) yield return loaded;
            }
        }
    }

    [Fact]
    public void LayerA_PureData_StructsMustBeSerializableAndSequential()
    {
        var failures = new List<string>();

        foreach (var asm in GetProjectAssemblies())
        {
            var types = asm.GetTypes()
                .Where(t => t.IsValueType && !t.IsEnum && !t.IsPrimitive && t.IsPublic && !t.Namespace!.Contains("Tests"));

            foreach (var type in types)
            {
                // Skip system/compiler generated (like enumerators)
                if (type.GetCustomAttribute<System.Runtime.CompilerServices.CompilerGeneratedAttribute>() != null) continue;

                // Exceptions to the rule?
                // RandomState is a struct but maybe logic? Memory says "RandomState struct manages state...".
                // Timer/Cooldown are structs.
                // IntentState is autogenerated logic struct (allowed exception).

                if (type.Name == "IntentState" && asm.GetName().Name == "GameVariable.Intent") continue;
                if (type.Name == "RpgStatSheet" && asm.GetName().Name == "Variable.RPG") continue; // Memory says RpgStatSheet is unmanaged/exempt.

                // Check Serializable
                if (type.GetCustomAttribute<SerializableAttribute>() == null)
                {
                    failures.Add($"Layer A Violation: Struct '{type.FullName}' is missing [Serializable].");
                }

                // Check StructLayout
                var layout = type.StructLayoutAttribute;
                if (layout == null || layout.Value != LayoutKind.Sequential)
                {
                    failures.Add($"Layer A Violation: Struct '{type.FullName}' must have [StructLayout(LayoutKind.Sequential)].");
                }

                // Check No Logic (Methods)
                // We allow getters/setters (Properties generated methods), Constructor, ToString, Equals, GetHashCode.
                // We disallow "Update", "Tick", "Calculate".
                var methods = type.GetMethods(BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly);
                foreach (var method in methods)
                {
                    if (method.IsSpecialName) continue; // Property getters/setters
                    if (method.Name == "ToString" || method.Name == "Equals" || method.Name == "GetHashCode") continue;

                    // Interface implementations might force methods?
                    // IBoundedInfo has GetRatio().
                    // Wait, AGENTS.md says "NO Logic. No methods."
                    // But Memory says "All bounded types implement IBoundedInfo...". IBoundedInfo likely has methods.
                    // Let's check IBoundedInfo definition if possible.
                    // For now, fail if "Tick" or "Update" is found.
                    if (method.Name == "Tick" || method.Name == "Update")
                    {
                        failures.Add($"Layer A Violation: Struct '{type.FullName}' contains logic method '{method.Name}'. Structs should be pure data.");
                    }
                }
            }
        }

        Assert.True(failures.Count == 0, string.Join(Environment.NewLine, failures));
    }

    [Fact]
    public void LayerB_CoreLogic_MustBeStatelessStatic()
    {
        var failures = new List<string>();

        foreach (var asm in GetProjectAssemblies())
        {
            var types = asm.GetTypes()
                .Where(t => t.IsClass && t.IsPublic && t.Name.EndsWith("Logic"));

            foreach (var type in types)
            {
                // Must be static (abstract and sealed in IL)
                if (!type.IsAbstract || !type.IsSealed)
                {
                    failures.Add($"Layer B Violation: Logic class '{type.FullName}' must be static.");
                }

                // Must be stateless (no static fields)
                var fields = type.GetFields(BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Static | BindingFlags.DeclaredOnly);
                foreach (var field in fields)
                {
                    if (!field.IsLiteral && !field.IsInitOnly) // Const and readonly are okay? Ideally NO state.
                    {
                         // Actually "Stateless" means no mutable state. Const is fine. Readonly static might be config, but acceptable.
                         // Mutable static fields are banned.
                         failures.Add($"Layer B Violation: Logic class '{type.FullName}' has static field '{field.Name}'. Logic must be stateless.");
                    }
                }

                // Methods must return void or bool
                var methods = type.GetMethods(BindingFlags.Public | BindingFlags.Static | BindingFlags.DeclaredOnly);
                foreach (var method in methods)
                {
                    if (method.IsSpecialName) continue;
                    if (method.ReturnType != typeof(void) && method.ReturnType != typeof(bool))
                    {
                        failures.Add($"Layer B Violation: Method '{type.FullName}.{method.Name}' returns '{method.ReturnType.Name}'. Logic methods must return void or bool.");
                    }
                }
            }
        }

        Assert.True(failures.Count == 0, string.Join(Environment.NewLine, failures));
    }

    [Fact]
    public void Naming_NoSingleLetters_NoHungarian()
    {
        var failures = new List<string>();
        // Allowed single letters
        var allowed = new HashSet<string> { "x", "y", "z", "r", "g", "b", "a" }; // Coordinates and colors

        foreach (var asm in GetProjectAssemblies())
        {
            var types = asm.GetTypes().Where(t => t.IsPublic);
            foreach (var type in types)
            {
                // Check properties and fields
                var members = type.GetMembers(BindingFlags.Public | BindingFlags.Instance | BindingFlags.Static | BindingFlags.DeclaredOnly);
                foreach (var member in members)
                {
                    if (member.Name.Length == 1 && !allowed.Contains(member.Name.ToLower()))
                    {
                        failures.Add($"Naming Violation: '{type.FullName}.{member.Name}' is a single letter.");
                    }

                    // Hungarian notation checks (heuristic)
                    // iCount, fValue, strName, bIsDead
                    if (IsHungarian(member.Name))
                    {
                        failures.Add($"Naming Violation: '{type.FullName}.{member.Name}' appears to use Hungarian notation.");
                    }
                }

                // Check method parameters
                if (type.IsClass || type.IsValueType || type.IsInterface)
                {
                     var methods = type.GetMethods(BindingFlags.Public | BindingFlags.Instance | BindingFlags.Static | BindingFlags.DeclaredOnly);
                     foreach(var m in methods)
                     {
                         foreach(var p in m.GetParameters())
                         {
                             if (p.Name!.Length == 1 && !allowed.Contains(p.Name.ToLower()))
                             {
                                 failures.Add($"Naming Violation: Parameter '{p.Name}' in '{type.FullName}.{m.Name}' is a single letter.");
                             }
                         }
                     }
                }
            }
        }

        Assert.True(failures.Count == 0, string.Join(Environment.NewLine, failures));
    }

    private bool IsHungarian(string name)
    {
        if (name.Length < 3) return false;
        // Check for common prefixes followed by Uppercase
        // iAge, fSpeed, bActive, strText
        if (char.IsLower(name[0]) && char.IsUpper(name[1]))
        {
            // simple check: starts with i, f, b, s, d, c
            char p = name[0];
            if (p == 'i' || p == 'f' || p == 'b' || p == 's' || p == 'd') return true;
            if (name.StartsWith("str") && char.IsUpper(name[3])) return true;
        }
        return false;
    }
}
