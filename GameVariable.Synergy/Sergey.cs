using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using Xunit;
using Xunit.Abstractions;

namespace GameVariable.Synergy;

public class Sergey
{
    private readonly ITestOutputHelper _output;

    public Sergey(ITestOutputHelper output)
    {
        _output = output;

        // Force load key assemblies if they aren't loaded (though references should handle this)
        // This is a safety measure to ensure AppDomain.GetAssemblies() finds them.
        var _ = new[] {
            typeof(Variable.Core.MathConstants),
            typeof(Variable.Inventory.InventoryLogic),
            typeof(Variable.Reservoir.ReservoirFloat),
            typeof(Variable.Timer.Timer),
            typeof(Variable.Bounded.BoundedFloat),
            typeof(GameVariable.Intent.IntentState)
        };
    }

    private static readonly HashSet<string> AllowedSingleLetters = new() { "x", "y", "z", "r", "g", "b", "a", "u", "v" };

    private static readonly HashSet<string> ExemptTypes = new()
    {
        "GameVariable.Intent.IntentState", // Autogenerated
        "Variable.RPG.RpgStatSheet",       // Unmanaged
        "Variable.Random.RandomState"      // Special case mentioned in memory? No, memory says it implements IEquatable.
    };

    private static IEnumerable<Type> GetDomainTypes()
    {
        return AppDomain.CurrentDomain.GetAssemblies()
            .Where(a => (a.FullName != null && (a.FullName.StartsWith("Variable.") || a.FullName.StartsWith("GameVariable.")))
                        && !a.FullName.Contains(".Tests")
                        && !a.FullName.Contains(".Synergy")
                        && !a.FullName.Contains(".Benchmarks"))
            .SelectMany(a => a.GetTypes())
            .Where(t => t.IsPublic && !t.IsInterface && !t.IsAbstract && !t.IsEnum || (t.IsAbstract && t.IsSealed)); // Include static classes (Abstract+Sealed) and public structs/classes
    }

    [Fact]
    public void LayerA_Structs_ShouldBePureData()
    {
        var types = GetDomainTypes()
            .Where(t => !t.IsAbstract && !t.Name.EndsWith("Logic") && !t.Name.EndsWith("Extensions") && !t.Name.EndsWith("Constants") && !t.Name.Contains("Exception"))
            .Where(t => t.FullName != null && !ExemptTypes.Contains(t.FullName));

        foreach (var type in types)
        {
            if (type.IsClass && !type.IsValueType && type.BaseType != typeof(MulticastDelegate))
            {
                 // Classes are generally discouraged in Layer A, but maybe allowed?
                 // AGENTS.md says "Layer A: Pure Data (The Struct)".
                 // We'll warn or fail if we see classes that look like data holders.
                 // For now, let's strictly enforce structs for Data.
                 // But wait, what about helper classes?
                 // Let's stick to the rule: "Layer A: Pure Data (The Struct)".
                 // If it's not a struct, it's suspicious.
                 // However, we might have some legitimate classes. Let's filter to things in namespaces that look like they should be data.
                 // If the namespace is just `Variable.Feature`, and it's not Logic/Extensions, it should probably be a struct.
            }

            if (type.IsValueType && !type.IsEnum && !type.IsPrimitive)
            {
                // Must be Serializable
                Assert.True(type.IsSerializable, $"{type.Name} (Layer A) must be [Serializable].");

                // Must be Sequential Layout
                Assert.True(type.StructLayoutAttribute?.Value == LayoutKind.Sequential, $"{type.Name} (Layer A) must be [StructLayout(LayoutKind.Sequential)].");

                // No Logic Methods
                var methods = type.GetMethods(BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly);
                foreach (var method in methods)
                {
                    if (method.IsSpecialName) continue; // Property getters/setters
                    if (method.Name == "Equals" || method.Name == "GetHashCode" || method.Name == "ToString" || method.Name == "CompareTo" || method.Name == "Deconstruct" || method.Name == "TryFormat") continue;

                    Assert.Fail($"{type.Name} (Layer A) should not have logic method '{method.Name}'. Logic belongs in Layer B.");
                }
            }
        }
    }

    [Fact]
    public void LayerB_Logic_ShouldBeStatelessAndPrimitive()
    {
        var logicTypes = GetDomainTypes()
            .Where(t => t.Name.EndsWith("Logic") && t.FullName != null && !ExemptTypes.Contains(t.FullName));

        foreach (var type in logicTypes)
        {
            // Must be static
            Assert.True(type.IsAbstract && type.IsSealed, $"{type.Name} (Layer B) must be a static class.");

            // Methods must return void or bool
            var methods = type.GetMethods(BindingFlags.Public | BindingFlags.Static | BindingFlags.DeclaredOnly);
            foreach (var method in methods)
            {
                if (method.IsSpecialName) continue;

                var returnType = method.ReturnType;
                Assert.True(returnType == typeof(void) || returnType == typeof(bool),
                    $"{type.Name}.{method.Name} (Layer B) must return void or bool. Found: {returnType.Name}");

                // Parameters must not be Layer A structs (heuristically)
                // We check if any parameter is a struct from our own assemblies (excluding primitives/system types)
                foreach (var param in method.GetParameters())
                {
                    var paramType = param.ParameterType;
                    if (paramType.IsByRef) paramType = paramType.GetElementType(); // Handle ref/out/in

                    if (IsDomainStruct(paramType))
                    {
                        Assert.Fail($"{type.Name}.{method.Name} (Layer B) has parameter '{param.Name}' of type '{paramType?.Name}'. " +
                                    $"Logic layer must take primitives, not Structs. Break it down.");
                    }
                }
            }
        }
    }

    [Fact]
    public void Naming_ShouldBeClean()
    {
        var types = GetDomainTypes().Where(t => t.FullName != null && !ExemptTypes.Contains(t.FullName));

        foreach (var type in types)
        {
            // Check properties and fields
            var members = type.GetMembers(BindingFlags.Public | BindingFlags.Instance | BindingFlags.Static | BindingFlags.DeclaredOnly);

            foreach (var member in members)
            {
                if (member is MethodInfo methodInfo && methodInfo.IsSpecialName) continue; // Skip property accessors

                CheckName(member.Name, $"{type.Name}.{member.Name}");
            }

            // Check method parameters
            if (type.IsAbstract && type.IsSealed) // Static class (likely Logic)
            {
                var methods = type.GetMethods(BindingFlags.Public | BindingFlags.Static | BindingFlags.DeclaredOnly);
                foreach (var method in methods)
                {
                    foreach (var param in method.GetParameters())
                    {
                        CheckName(param.Name, $"{type.Name}.{method.Name}(param: {param.Name})");
                    }
                }
            }
        }
    }

    private void CheckName(string? name, string context)
    {
        if (string.IsNullOrEmpty(name)) return;
        if (name == "value") return; // Property setter standard

        // Rule 1: No single letters (except allowed)
        if (name.Length == 1 && !AllowedSingleLetters.Contains(name.ToLower()))
        {
             // Context check: Is it a coordinate? x, y, z are in allowed list.
             Assert.Fail($"Name '{name}' in {context} is too short. Banned single letters.");
        }

        // Rule 2: No Hungarian (heuristic: starts with lower case letter indicating type, followed by Upper)
        // e.g. iAge, strName, bDead.
        // We only flag if it looks really suspicious.
        // Regex: ^[bsifd][A-Z]
        if (System.Text.RegularExpressions.Regex.IsMatch(name, "^[bsifd][A-Z]"))
        {
             // We need to be careful not to flag "dTime" (delta time) if that's common, but AGENTS.md says "d" is banned.
             // "bIsDead" is explicitly banned.
             Assert.Fail($"Name '{name}' in {context} looks like Hungarian notation (e.g. bIsDead). Avoid type prefixes.");
        }
    }

    private bool IsDomainStruct(Type? type)
    {
        if (type == null) return false;
        if (!type.IsValueType || type.IsPrimitive || type.IsEnum) return false;
        if (type.Namespace != null && (type.Namespace.StartsWith("System") || type.Namespace.StartsWith("Microsoft"))) return false;

        // It's a struct in our domain
        return type.Assembly.FullName!.StartsWith("Variable.") || type.Assembly.FullName.StartsWith("GameVariable.");
    }
}
