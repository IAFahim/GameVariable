<!-- 
  -- This file was generated by StateSmith.
  -- Note! The generated state machine code in this file has been specially instrumented to support simulator features.
  -- Regular generated javascript state machine code is smaller and simpler.
  -->
<html>
<head>
    <link rel='icon' type='image/png' href='https://statesmith.github.io/favicon.png'>
    <link rel='stylesheet' href='https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined'>
    <style>
        body {
            display: flex;
            flex-direction: row;
            margin: 0px;
        }

        /* Fix for mermaid content requiring scroll bars https://github.com/StateSmith/StateSmith/issues/288 */
        pre.mermaid {
            margin: 0px;
        }

        .wrapper {
            height: 100vh;
            width: 100vw;
            display: flex;
        }

        .pane {
            padding: 1em;
            min-width: 200px;
        }

        .titlebar-icon {
            font-family: 'Material Symbols Outlined', sans-serif;
            font-size: 16px;
            color: #777;
            border-radius: 5px;
        }

        .gutter {
            width: 10px;
            height: 100%;
            background: #ccc;
            position: absolute;
            top: 0;
            left: 0;
            cursor: col-resize;
        }

        .main {
            flex: 1;
            overflow: auto;
            padding: 10px;
        }

        .sidebar {
            width: 300px;
            padding-top: 0px;
            position: relative;
            background-color: #f0f0f0;
            border-left: 1px solid #ccc;
            display: flex;
            flex-direction: column;
        }

        #buttons {
            display: flex;
            flex-direction: column;
        }

        .titlebar {
            background-color: #ddd;
            border-bottom: 1px solid #ccc;
            font-weight: bold;
            padding: 5px;
            display: flex;
        }

        .console {
            border-collapse: collapse;
            margin-top: 10px;
            width: 100%;
        }

        table.console td.timestamp {
            display: none;
        }

        table.console.timestamps td.timestamp {
            display: table-cell;
        }

        table.console td {
            color: rgba(0, 0, 0, 0.7);
        }

        table.console td .dispatched {
            font-weight: bold;
            color: rgba(0, 0, 0, 1);
        }

        table.console tr:has(+tr td .dispatched) {
            border-bottom: 0px;
        }

        table.console tr:has(+tr td .dispatched) td {
            padding-bottom: 25px;
        }

        .console th {
            background-color: #f0f0f0;
            border-bottom: 1px solid #ccc;
            font-weight: normal;
            padding: 5px;
            text-align: left;
        }

        .console tbody {
            font-family: monospace;
        }

        .console tr {
            border-bottom: 1px solid #ccc;
        }

        .console td {
            padding: 5px;
        }

        .console td.timestamp {
            font-size: small;
        }

        .history {
            margin-top: 30px;
            display: flex;
            overflow: auto;
            flex-direction: column-reverse;
        }

        .console tr:last-child td {
            border-bottom: none;
        }

        .dispatched {
            font-weight: bold;
        }

        .dispatched > .trigger {
            border: 1px solid #000;
            border-radius: 4px;
            padding: 2px 10px 2px 10px;
        }

        button {
            margin: 5px;
        }

        button.event-button {
            transition: opacity 0.3s ease, background-color 0.3s ease;
            opacity: 1;
            background-color: #007bff;
            color: white;
            cursor: pointer;
        }

        button.event-button:disabled {
            opacity: 0.4;
            background-color: #f0f0f0;
            color: #999;
            cursor: not-allowed;
        }

        button.event-button:not(:disabled):hover {
            background-color: #0056b3;
        }

        /* Style for hiding irrelevant events */
        button.event-button.hidden {
            display: none;
        }



        /* ----------------------------- Dropdown related start ----------------------------- */

        .dropdown-button {
            border: none;
            cursor: pointer;
        }

        .dropdown-button:hover, .dropdown-button:focus {
            background-color: #f1f1f1;
        }

        .dropdown {
            position: relative;
            display: inline-block;
            margin-left: auto;
        }

        .dropdown-content {
            display: none;
            position: absolute;
            right: 0;
            background-color: #f1f1f1;
            min-width: 250px;
            overflow: auto;
            box-shadow: 0px 8px 16px 0px rgba(0,0,0,0.2);
            z-index: 1;
        }

        .dropdown-content .dropdown-item {
            display: block;
            padding: 12px 16px;
            font-weight: normal;
        }

        .dropdown-content .dropdown-item:hover {
            background-color: #ddd;
            cursor: pointer;
        }

        .show {
            display: block;
        }

        /* ----------------------------- Dropdown related end ----------------------------- */



        .transition.active {
            stroke: #fff5ad !important;
            stroke-width: 5px !important;
            filter: drop-shadow( 3px 3px 2px rgba(0, 0, 0, .7));
        }

        .statediagram-state.active > * {
            fill: #fff5ad !important;
            stroke-width: 2px !important;
        }

    </style>
</head>

<body>
<div class="wrapper">
    <div class="pane main">
        <pre class="mermaid">
stateDiagram

CREATED

CREATED : CREATED

INACTIVE

INACTIVE : INACTIVE

PENDING

PENDING : PENDING

RUNNING

RUNNING : RUNNING

BLOCKED

BLOCKED : BLOCKED

COMPLETED

COMPLETED : COMPLETED

FAULTED

FAULTED : FAULTED

CANCELLED

CANCELLED : CANCELLED

%% Initial state name as "." so that it fits in black circle shape.
%% See https://github.com/StateSmith/StateSmith/issues/404
state "." as ROOT.(InitialState)

CREATED --> INACTIVE : PREPARE

CREATED --> PENDING : ACTIVATE

CREATED --> CANCELLED : CANCEL

INACTIVE --> PENDING : ACTIVATE

INACTIVE --> CANCELLED : CANCEL

PENDING --> RUNNING : START

PENDING --> CANCELLED : CANCEL

RUNNING --> COMPLETED : COMPLETE

RUNNING --> BLOCKED : SPAWN_CHILD

RUNNING --> FAULTED : FAIL

RUNNING --> CANCELLED : CANCEL

BLOCKED --> RUNNING : RESUME

BLOCKED --> FAULTED : ABORT

BLOCKED --> CANCELLED : CANCEL

COMPLETED --> PENDING : RESTART

FAULTED --> PENDING : RECOVER

FAULTED --> CANCELLED : CANCEL

ROOT.(InitialState) --> CREATED



        </pre>
    </div>

    <div class="pane sidebar">
        <div id="buttons">
            <div class="titlebar">Events
                <div class='dropdown'>
                    <span id='dropdown-button' class='titlebar-icon dropdown-button'>settings</span>
                    <div id='myDropdown' class='dropdown-content'>
                        <label class='dropdown-item' for='hideIrrelevantEvents'
                               title='When enabled, event dispatching buttons will be hidden if the current active state(s) ignore the event.'>
                            <input type='checkbox' id='hideIrrelevantEvents' name='hideIrrelevantEvents'>
                            Hide ignored event buttons
                        </label>
                        <label class='dropdown-item' for='timestamps'
                               title='Controls whether timestamps are shown along side event dispatches.'>
                            <input type='checkbox' id='timestamps' name='timestamps'>
                            Timestamps
                        </label>
                    </div>
                </div>
            </div>
        </div>

        <div class="history">
            <table class="console">
                <tbody>
                </tbody>
            </table>
        </div>

        <div class="gutter"></div>
    </div>
</div>

<script>
    // Autogenerated with StateSmith 0.19.0-alpha-1+5931a3a68e50c80e83349118a90569bf08270686.
    // Algorithm: Balanced2. See https://github.com/StateSmith/StateSmith/wiki/Algorithms

    // Generated state machine
    class IntentState
    {
// Null by default.
// May be overridden to override guard evaluation (eg. in a simulator)
        evaluateGuard = null;
        static EventId =
            {
                ABORT : 0,
                ACTIVATE : 1,
                CANCEL : 2,
                COMPLETE : 3,
                FAIL : 4,
                PREPARE : 5,
                RECOVER : 6,
                RESTART : 7,
                RESUME : 8,
                SPAWN_CHILD : 9,
                START : 10,
            }
        static { Object.freeze(this.EventId); }

        static EventIdCount = 11;
        static { Object.freeze(this.EventIdCount); }

        static StateId =
            {
                ROOT : 0,
                BLOCKED : 1,
                CANCELLED : 2,
                COMPLETED : 3,
                CREATED : 4,
                FAULTED : 5,
                INACTIVE : 6,
                PENDING : 7,
                RUNNING : 8,
            }
        static { Object.freeze(this.StateId); }

        static StateIdCount = 9;
        static { Object.freeze(this.StateIdCount); }

        // Used internally by state machine. Feel free to inspect, but don't modify.
        stateId;

        // Starts the state machine. Must be called before dispatching events. Not thread safe.
        start()
        {
            this.#ROOT_enter();
            // ROOT behavior
            // uml: TransitionTo(ROOT.<InitialState>)
            {
                // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition). Already at LCA, no exiting required.

                // Step 2: Transition action: ``.

                // Step 3: Enter/move towards transition target `ROOT.<InitialState>`.
                // ROOT.<InitialState> is a pseudo state and cannot have an `enter` trigger.

                // ROOT.<InitialState> behavior
                // uml: / { this.tracer?.edgeTransition("edge17"); } TransitionTo(CREATED)
                {
                    // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition). Already at LCA, no exiting required.

                    // Step 2: Transition action: `this.tracer?.edgeTransition("edge17");`.
                    this.tracer?.edgeTransition("edge17");

                    // Step 3: Enter/move towards transition target `CREATED`.
                    this.#CREATED_enter();

                    // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
                    return;
                } // end of behavior for ROOT.<InitialState>
            } // end of behavior for ROOT
        }

        // Dispatches an event to the state machine. Not thread safe.
        // Note! This function assumes that the `eventId` parameter is valid.
        dispatchEvent(eventId)
        {
            switch (this.stateId)
            {
                // STATE: IntentState
                case IntentState.StateId.ROOT:
                    // No events handled by this state (or its ancestors).
                    break;

                // STATE: BLOCKED
                case IntentState.StateId.BLOCKED:
                    switch (eventId)
                    {
                        case IntentState.EventId.RESUME: this.#BLOCKED_resume(); break;
                        case IntentState.EventId.ABORT: this.#BLOCKED_abort(); break;
                        case IntentState.EventId.CANCEL: this.#BLOCKED_cancel(); break;
                    }
                    break;

                // STATE: CANCELLED
                case IntentState.StateId.CANCELLED:
                    // No events handled by this state (or its ancestors).
                    break;

                // STATE: COMPLETED
                case IntentState.StateId.COMPLETED:
                    switch (eventId)
                    {
                        case IntentState.EventId.RESTART: this.#COMPLETED_restart(); break;
                    }
                    break;

                // STATE: CREATED
                case IntentState.StateId.CREATED:
                    switch (eventId)
                    {
                        case IntentState.EventId.PREPARE: this.#CREATED_prepare(); break;
                        case IntentState.EventId.ACTIVATE: this.#CREATED_activate(); break;
                        case IntentState.EventId.CANCEL: this.#CREATED_cancel(); break;
                    }
                    break;

                // STATE: FAULTED
                case IntentState.StateId.FAULTED:
                    switch (eventId)
                    {
                        case IntentState.EventId.RECOVER: this.#FAULTED_recover(); break;
                        case IntentState.EventId.CANCEL: this.#FAULTED_cancel(); break;
                    }
                    break;

                // STATE: INACTIVE
                case IntentState.StateId.INACTIVE:
                    switch (eventId)
                    {
                        case IntentState.EventId.ACTIVATE: this.#INACTIVE_activate(); break;
                        case IntentState.EventId.CANCEL: this.#INACTIVE_cancel(); break;
                    }
                    break;

                // STATE: PENDING
                case IntentState.StateId.PENDING:
                    switch (eventId)
                    {
                        case IntentState.EventId.START: this.#PENDING_start(); break;
                        case IntentState.EventId.CANCEL: this.#PENDING_cancel(); break;
                    }
                    break;

                // STATE: RUNNING
                case IntentState.StateId.RUNNING:
                    switch (eventId)
                    {
                        case IntentState.EventId.COMPLETE: this.#RUNNING_complete(); break;
                        case IntentState.EventId.SPAWN_CHILD: this.#RUNNING_spawn_child(); break;
                        case IntentState.EventId.FAIL: this.#RUNNING_fail(); break;
                        case IntentState.EventId.CANCEL: this.#RUNNING_cancel(); break;
                    }
                    break;
            }

        }

        // This function is used when StateSmith doesn't know what the active leaf state is at
        // compile time due to sub states or when multiple states need to be exited.
        #exitUpToStateHandler(desiredState)
        {
            while (this.stateId != desiredState)
            {
                switch (this.stateId)
                {
                    case IntentState.StateId.BLOCKED: this.#BLOCKED_exit(); break;

                    case IntentState.StateId.CANCELLED: this.#CANCELLED_exit(); break;

                    case IntentState.StateId.COMPLETED: this.#COMPLETED_exit(); break;

                    case IntentState.StateId.CREATED: this.#CREATED_exit(); break;

                    case IntentState.StateId.FAULTED: this.#FAULTED_exit(); break;

                    case IntentState.StateId.INACTIVE: this.#INACTIVE_exit(); break;

                    case IntentState.StateId.PENDING: this.#PENDING_exit(); break;

                    case IntentState.StateId.RUNNING: this.#RUNNING_exit(); break;

                    default: return;  // Just to be safe. Prevents infinite loop if state ID memory is somehow corrupted.
                }
            }
        }


        ////////////////////////////////////////////////////////////////////////////////
        // event handlers for state ROOT
        ////////////////////////////////////////////////////////////////////////////////

        #ROOT_enter()
        {
            this.stateId = IntentState.StateId.ROOT;
        }


        ////////////////////////////////////////////////////////////////////////////////
        // event handlers for state BLOCKED
        ////////////////////////////////////////////////////////////////////////////////

        #BLOCKED_enter()
        {
            this.stateId = IntentState.StateId.BLOCKED;

            // BLOCKED behavior
            // uml: enter / { this.tracer?.enterState('BLOCKED'); }
            {
                // Step 1: execute action `this.tracer?.enterState('BLOCKED');`
                this.tracer?.enterState('BLOCKED');
            } // end of behavior for BLOCKED
        }

        #BLOCKED_exit()
        {
            // BLOCKED behavior
            // uml: exit / { this.tracer?.exitState('BLOCKED'); }
            {
                // Step 1: execute action `this.tracer?.exitState('BLOCKED');`
                this.tracer?.exitState('BLOCKED');
            } // end of behavior for BLOCKED

            this.stateId = IntentState.StateId.ROOT;
        }

        #BLOCKED_abort()
        {
            // BLOCKED behavior
            // uml: ABORT / { this.tracer?.edgeTransition("edge12"); } TransitionTo(FAULTED)
            {
                // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition).
                this.#BLOCKED_exit();

                // Step 2: Transition action: `this.tracer?.edgeTransition("edge12");`.
                this.tracer?.edgeTransition("edge12");

                // Step 3: Enter/move towards transition target `FAULTED`.
                this.#FAULTED_enter();

                // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
                return;
            } // end of behavior for BLOCKED

            // No ancestor handles this event.
        }

        #BLOCKED_cancel()
        {
            // BLOCKED behavior
            // uml: CANCEL / { this.tracer?.edgeTransition("edge13"); } TransitionTo(CANCELLED)
            {
                // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition).
                this.#BLOCKED_exit();

                // Step 2: Transition action: `this.tracer?.edgeTransition("edge13");`.
                this.tracer?.edgeTransition("edge13");

                // Step 3: Enter/move towards transition target `CANCELLED`.
                this.#CANCELLED_enter();

                // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
                return;
            } // end of behavior for BLOCKED

            // No ancestor handles this event.
        }

        #BLOCKED_resume()
        {
            // BLOCKED behavior
            // uml: RESUME / { this.tracer?.edgeTransition("edge11"); } TransitionTo(RUNNING)
            {
                // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition).
                this.#BLOCKED_exit();

                // Step 2: Transition action: `this.tracer?.edgeTransition("edge11");`.
                this.tracer?.edgeTransition("edge11");

                // Step 3: Enter/move towards transition target `RUNNING`.
                this.#RUNNING_enter();

                // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
                return;
            } // end of behavior for BLOCKED

            // No ancestor handles this event.
        }


        ////////////////////////////////////////////////////////////////////////////////
        // event handlers for state CANCELLED
        ////////////////////////////////////////////////////////////////////////////////

        #CANCELLED_enter()
        {
            this.stateId = IntentState.StateId.CANCELLED;

            // CANCELLED behavior
            // uml: enter / { this.tracer?.enterState('CANCELLED'); }
            {
                // Step 1: execute action `this.tracer?.enterState('CANCELLED');`
                this.tracer?.enterState('CANCELLED');
            } // end of behavior for CANCELLED
        }

        #CANCELLED_exit()
        {
            // CANCELLED behavior
            // uml: exit / { this.tracer?.exitState('CANCELLED'); }
            {
                // Step 1: execute action `this.tracer?.exitState('CANCELLED');`
                this.tracer?.exitState('CANCELLED');
            } // end of behavior for CANCELLED

            this.stateId = IntentState.StateId.ROOT;
        }


        ////////////////////////////////////////////////////////////////////////////////
        // event handlers for state COMPLETED
        ////////////////////////////////////////////////////////////////////////////////

        #COMPLETED_enter()
        {
            this.stateId = IntentState.StateId.COMPLETED;

            // COMPLETED behavior
            // uml: enter / { this.tracer?.enterState('COMPLETED'); }
            {
                // Step 1: execute action `this.tracer?.enterState('COMPLETED');`
                this.tracer?.enterState('COMPLETED');
            } // end of behavior for COMPLETED
        }

        #COMPLETED_exit()
        {
            // COMPLETED behavior
            // uml: exit / { this.tracer?.exitState('COMPLETED'); }
            {
                // Step 1: execute action `this.tracer?.exitState('COMPLETED');`
                this.tracer?.exitState('COMPLETED');
            } // end of behavior for COMPLETED

            this.stateId = IntentState.StateId.ROOT;
        }

        #COMPLETED_restart()
        {
            // COMPLETED behavior
            // uml: RESTART / { this.tracer?.edgeTransition("edge14"); } TransitionTo(PENDING)
            {
                // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition).
                this.#COMPLETED_exit();

                // Step 2: Transition action: `this.tracer?.edgeTransition("edge14");`.
                this.tracer?.edgeTransition("edge14");

                // Step 3: Enter/move towards transition target `PENDING`.
                this.#PENDING_enter();

                // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
                return;
            } // end of behavior for COMPLETED

            // No ancestor handles this event.
        }


        ////////////////////////////////////////////////////////////////////////////////
        // event handlers for state CREATED
        ////////////////////////////////////////////////////////////////////////////////

        #CREATED_enter()
        {
            this.stateId = IntentState.StateId.CREATED;

            // CREATED behavior
            // uml: enter / { this.tracer?.enterState('CREATED'); }
            {
                // Step 1: execute action `this.tracer?.enterState('CREATED');`
                this.tracer?.enterState('CREATED');
            } // end of behavior for CREATED
        }

        #CREATED_exit()
        {
            // CREATED behavior
            // uml: exit / { this.tracer?.exitState('CREATED'); }
            {
                // Step 1: execute action `this.tracer?.exitState('CREATED');`
                this.tracer?.exitState('CREATED');
            } // end of behavior for CREATED

            this.stateId = IntentState.StateId.ROOT;
        }

        #CREATED_activate()
        {
            // CREATED behavior
            // uml: ACTIVATE / { this.tracer?.edgeTransition("edge1"); } TransitionTo(PENDING)
            {
                // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition).
                this.#CREATED_exit();

                // Step 2: Transition action: `this.tracer?.edgeTransition("edge1");`.
                this.tracer?.edgeTransition("edge1");

                // Step 3: Enter/move towards transition target `PENDING`.
                this.#PENDING_enter();

                // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
                return;
            } // end of behavior for CREATED

            // No ancestor handles this event.
        }

        #CREATED_cancel()
        {
            // CREATED behavior
            // uml: CANCEL / { this.tracer?.edgeTransition("edge2"); } TransitionTo(CANCELLED)
            {
                // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition).
                this.#CREATED_exit();

                // Step 2: Transition action: `this.tracer?.edgeTransition("edge2");`.
                this.tracer?.edgeTransition("edge2");

                // Step 3: Enter/move towards transition target `CANCELLED`.
                this.#CANCELLED_enter();

                // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
                return;
            } // end of behavior for CREATED

            // No ancestor handles this event.
        }

        #CREATED_prepare()
        {
            // CREATED behavior
            // uml: PREPARE / { this.tracer?.edgeTransition("edge0"); } TransitionTo(INACTIVE)
            {
                // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition).
                this.#CREATED_exit();

                // Step 2: Transition action: `this.tracer?.edgeTransition("edge0");`.
                this.tracer?.edgeTransition("edge0");

                // Step 3: Enter/move towards transition target `INACTIVE`.
                this.#INACTIVE_enter();

                // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
                return;
            } // end of behavior for CREATED

            // No ancestor handles this event.
        }


        ////////////////////////////////////////////////////////////////////////////////
        // event handlers for state FAULTED
        ////////////////////////////////////////////////////////////////////////////////

        #FAULTED_enter()
        {
            this.stateId = IntentState.StateId.FAULTED;

            // FAULTED behavior
            // uml: enter / { this.tracer?.enterState('FAULTED'); }
            {
                // Step 1: execute action `this.tracer?.enterState('FAULTED');`
                this.tracer?.enterState('FAULTED');
            } // end of behavior for FAULTED
        }

        #FAULTED_exit()
        {
            // FAULTED behavior
            // uml: exit / { this.tracer?.exitState('FAULTED'); }
            {
                // Step 1: execute action `this.tracer?.exitState('FAULTED');`
                this.tracer?.exitState('FAULTED');
            } // end of behavior for FAULTED

            this.stateId = IntentState.StateId.ROOT;
        }

        #FAULTED_cancel()
        {
            // FAULTED behavior
            // uml: CANCEL / { this.tracer?.edgeTransition("edge16"); } TransitionTo(CANCELLED)
            {
                // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition).
                this.#FAULTED_exit();

                // Step 2: Transition action: `this.tracer?.edgeTransition("edge16");`.
                this.tracer?.edgeTransition("edge16");

                // Step 3: Enter/move towards transition target `CANCELLED`.
                this.#CANCELLED_enter();

                // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
                return;
            } // end of behavior for FAULTED

            // No ancestor handles this event.
        }

        #FAULTED_recover()
        {
            // FAULTED behavior
            // uml: RECOVER / { this.tracer?.edgeTransition("edge15"); } TransitionTo(PENDING)
            {
                // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition).
                this.#FAULTED_exit();

                // Step 2: Transition action: `this.tracer?.edgeTransition("edge15");`.
                this.tracer?.edgeTransition("edge15");

                // Step 3: Enter/move towards transition target `PENDING`.
                this.#PENDING_enter();

                // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
                return;
            } // end of behavior for FAULTED

            // No ancestor handles this event.
        }


        ////////////////////////////////////////////////////////////////////////////////
        // event handlers for state INACTIVE
        ////////////////////////////////////////////////////////////////////////////////

        #INACTIVE_enter()
        {
            this.stateId = IntentState.StateId.INACTIVE;

            // INACTIVE behavior
            // uml: enter / { this.tracer?.enterState('INACTIVE'); }
            {
                // Step 1: execute action `this.tracer?.enterState('INACTIVE');`
                this.tracer?.enterState('INACTIVE');
            } // end of behavior for INACTIVE
        }

        #INACTIVE_exit()
        {
            // INACTIVE behavior
            // uml: exit / { this.tracer?.exitState('INACTIVE'); }
            {
                // Step 1: execute action `this.tracer?.exitState('INACTIVE');`
                this.tracer?.exitState('INACTIVE');
            } // end of behavior for INACTIVE

            this.stateId = IntentState.StateId.ROOT;
        }

        #INACTIVE_activate()
        {
            // INACTIVE behavior
            // uml: ACTIVATE / { this.tracer?.edgeTransition("edge3"); } TransitionTo(PENDING)
            {
                // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition).
                this.#INACTIVE_exit();

                // Step 2: Transition action: `this.tracer?.edgeTransition("edge3");`.
                this.tracer?.edgeTransition("edge3");

                // Step 3: Enter/move towards transition target `PENDING`.
                this.#PENDING_enter();

                // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
                return;
            } // end of behavior for INACTIVE

            // No ancestor handles this event.
        }

        #INACTIVE_cancel()
        {
            // INACTIVE behavior
            // uml: CANCEL / { this.tracer?.edgeTransition("edge4"); } TransitionTo(CANCELLED)
            {
                // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition).
                this.#INACTIVE_exit();

                // Step 2: Transition action: `this.tracer?.edgeTransition("edge4");`.
                this.tracer?.edgeTransition("edge4");

                // Step 3: Enter/move towards transition target `CANCELLED`.
                this.#CANCELLED_enter();

                // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
                return;
            } // end of behavior for INACTIVE

            // No ancestor handles this event.
        }


        ////////////////////////////////////////////////////////////////////////////////
        // event handlers for state PENDING
        ////////////////////////////////////////////////////////////////////////////////

        #PENDING_enter()
        {
            this.stateId = IntentState.StateId.PENDING;

            // PENDING behavior
            // uml: enter / { this.tracer?.enterState('PENDING'); }
            {
                // Step 1: execute action `this.tracer?.enterState('PENDING');`
                this.tracer?.enterState('PENDING');
            } // end of behavior for PENDING
        }

        #PENDING_exit()
        {
            // PENDING behavior
            // uml: exit / { this.tracer?.exitState('PENDING'); }
            {
                // Step 1: execute action `this.tracer?.exitState('PENDING');`
                this.tracer?.exitState('PENDING');
            } // end of behavior for PENDING

            this.stateId = IntentState.StateId.ROOT;
        }

        #PENDING_cancel()
        {
            // PENDING behavior
            // uml: CANCEL / { this.tracer?.edgeTransition("edge6"); } TransitionTo(CANCELLED)
            {
                // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition).
                this.#PENDING_exit();

                // Step 2: Transition action: `this.tracer?.edgeTransition("edge6");`.
                this.tracer?.edgeTransition("edge6");

                // Step 3: Enter/move towards transition target `CANCELLED`.
                this.#CANCELLED_enter();

                // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
                return;
            } // end of behavior for PENDING

            // No ancestor handles this event.
        }

        #PENDING_start()
        {
            // PENDING behavior
            // uml: START / { this.tracer?.edgeTransition("edge5"); } TransitionTo(RUNNING)
            {
                // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition).
                this.#PENDING_exit();

                // Step 2: Transition action: `this.tracer?.edgeTransition("edge5");`.
                this.tracer?.edgeTransition("edge5");

                // Step 3: Enter/move towards transition target `RUNNING`.
                this.#RUNNING_enter();

                // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
                return;
            } // end of behavior for PENDING

            // No ancestor handles this event.
        }


        ////////////////////////////////////////////////////////////////////////////////
        // event handlers for state RUNNING
        ////////////////////////////////////////////////////////////////////////////////

        #RUNNING_enter()
        {
            this.stateId = IntentState.StateId.RUNNING;

            // RUNNING behavior
            // uml: enter / { this.tracer?.enterState('RUNNING'); }
            {
                // Step 1: execute action `this.tracer?.enterState('RUNNING');`
                this.tracer?.enterState('RUNNING');
            } // end of behavior for RUNNING
        }

        #RUNNING_exit()
        {
            // RUNNING behavior
            // uml: exit / { this.tracer?.exitState('RUNNING'); }
            {
                // Step 1: execute action `this.tracer?.exitState('RUNNING');`
                this.tracer?.exitState('RUNNING');
            } // end of behavior for RUNNING

            this.stateId = IntentState.StateId.ROOT;
        }

        #RUNNING_cancel()
        {
            // RUNNING behavior
            // uml: CANCEL / { this.tracer?.edgeTransition("edge10"); } TransitionTo(CANCELLED)
            {
                // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition).
                this.#RUNNING_exit();

                // Step 2: Transition action: `this.tracer?.edgeTransition("edge10");`.
                this.tracer?.edgeTransition("edge10");

                // Step 3: Enter/move towards transition target `CANCELLED`.
                this.#CANCELLED_enter();

                // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
                return;
            } // end of behavior for RUNNING

            // No ancestor handles this event.
        }

        #RUNNING_complete()
        {
            // RUNNING behavior
            // uml: COMPLETE / { this.tracer?.edgeTransition("edge7"); } TransitionTo(COMPLETED)
            {
                // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition).
                this.#RUNNING_exit();

                // Step 2: Transition action: `this.tracer?.edgeTransition("edge7");`.
                this.tracer?.edgeTransition("edge7");

                // Step 3: Enter/move towards transition target `COMPLETED`.
                this.#COMPLETED_enter();

                // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
                return;
            } // end of behavior for RUNNING

            // No ancestor handles this event.
        }

        #RUNNING_fail()
        {
            // RUNNING behavior
            // uml: FAIL / { this.tracer?.edgeTransition("edge9"); } TransitionTo(FAULTED)
            {
                // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition).
                this.#RUNNING_exit();

                // Step 2: Transition action: `this.tracer?.edgeTransition("edge9");`.
                this.tracer?.edgeTransition("edge9");

                // Step 3: Enter/move towards transition target `FAULTED`.
                this.#FAULTED_enter();

                // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
                return;
            } // end of behavior for RUNNING

            // No ancestor handles this event.
        }

        #RUNNING_spawn_child()
        {
            // RUNNING behavior
            // uml: SPAWN_CHILD / { this.tracer?.edgeTransition("edge8"); } TransitionTo(BLOCKED)
            {
                // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition).
                this.#RUNNING_exit();

                // Step 2: Transition action: `this.tracer?.edgeTransition("edge8");`.
                this.tracer?.edgeTransition("edge8");

                // Step 3: Enter/move towards transition target `BLOCKED`.
                this.#BLOCKED_enter();

                // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
                return;
            } // end of behavior for RUNNING

            // No ancestor handles this event.
        }

        // Thread safe.
        static stateIdToString(id)
        {
            switch (id)
            {
                case IntentState.StateId.ROOT: return "ROOT";
                case IntentState.StateId.BLOCKED: return "BLOCKED";
                case IntentState.StateId.CANCELLED: return "CANCELLED";
                case IntentState.StateId.COMPLETED: return "COMPLETED";
                case IntentState.StateId.CREATED: return "CREATED";
                case IntentState.StateId.FAULTED: return "FAULTED";
                case IntentState.StateId.INACTIVE: return "INACTIVE";
                case IntentState.StateId.PENDING: return "PENDING";
                case IntentState.StateId.RUNNING: return "RUNNING";
                default: return "?";
            }
        }

        // Thread safe.
        static eventIdToString(id)
        {
            switch (id)
            {
                case IntentState.EventId.ABORT: return "ABORT";
                case IntentState.EventId.ACTIVATE: return "ACTIVATE";
                case IntentState.EventId.CANCEL: return "CANCEL";
                case IntentState.EventId.COMPLETE: return "COMPLETE";
                case IntentState.EventId.FAIL: return "FAIL";
                case IntentState.EventId.PREPARE: return "PREPARE";
                case IntentState.EventId.RECOVER: return "RECOVER";
                case IntentState.EventId.RESTART: return "RESTART";
                case IntentState.EventId.RESUME: return "RESUME";
                case IntentState.EventId.SPAWN_CHILD: return "SPAWN_CHILD";
                case IntentState.EventId.START: return "START";
                default: return "?";
            }
        }
    }

</script>

<script type="module">
    import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs';
    import svgPanZoom from 'https://cdn.jsdelivr.net/npm/svg-pan-zoom@3.6.1/+esm' ;
    mermaid.initialize({ startOnLoad: false });
    await mermaid.run();

    // svg-pan-zoom doesn't like the mermaid viewbox
    document.querySelector('svg').removeAttribute('viewBox');
    document.querySelector('svg').setAttribute('width', '100%');
    document.querySelector('svg').setAttribute('height', '100%');
    document.querySelector('svg').style["max-width"] = '';

    // don't scale the arrow when we scale the transition edge
    document.querySelectorAll('g defs marker[id$=barbEnd]').forEach(marker => {
        marker.setAttribute('markerUnits', 'userSpaceOnUse');
    });

    // https://github.com/StateSmith/StateSmith/issues/404
    // https://github.com/StateSmith/StateSmith/issues/294
    // rewrite $initial_state to a black circle
    document.querySelectorAll('g[data-id*="(InitialState)"]').forEach(g=> {
        g.innerHTML = '<circle transform="translate(0,3)" height="14" width="14" r="14" class="state - start"></circle>';
    })

    var panZoom = window.panZoom = svgPanZoom(document.querySelector('svg'), {
        zoomEnabled: true,
        controlIconsEnabled: true,
        fit: true,
        center: true
    });

    const diagramEventNamesArray = ['ABORT', 'ACTIVATE', 'CANCEL', 'COMPLETE', 'FAIL', 'PREPARE', 'RECOVER', 'RESTART', 'RESUME', 'SPAWN_CHILD', 'START', ];

    // Mapping from state to available events
    const stateEventsMapping = {
        "CREATED": [
            "ACTIVATE",
            "CANCEL",
            "PREPARE"
        ],
        "INACTIVE": [
            "ACTIVATE",
            "CANCEL"
        ],
        "PENDING": [
            "CANCEL",
            "START"
        ],
        "RUNNING": [
            "CANCEL",
            "COMPLETE",
            "FAIL",
            "SPAWN_CHILD"
        ],
        "BLOCKED": [
            "ABORT",
            "CANCEL",
            "RESUME"
        ],
        "COMPLETED": [
            "RESTART"
        ],
        "FAULTED": [
            "CANCEL",
            "RECOVER"
        ],
        "CANCELLED": []
    };

    // Get page element references
    const leftPane = document.querySelector(".main");
    const rightPane = document.querySelector(".sidebar");
    const gutter = document.querySelector(".gutter");

    // Function to resize panes
    function resizer(e) {
        window.addEventListener('mousemove', mousemove);
        window.addEventListener('mouseup', mouseup);
        let prevX = e.x;
        const rightPanel = rightPane.getBoundingClientRect();

        function mousemove(e) {
            let newX = prevX - e.x;
            rightPane.style.width = rightPanel.width + newX + 'px';
            window.panZoom.resize();
            window.panZoom.fit();
            window.panZoom.center();
        }

        function mouseup() {
            window.removeEventListener('mousemove', mousemove);
            window.removeEventListener('mouseup', mouseup);
        }
    }

    // Add mouse down event listener for the resizer
    gutter.addEventListener('mousedown', resizer);



    //------------------- drop down functionality start -------------------
    const dropdownButton = document.getElementById('dropdown-button');
    const dropdownDiv = document.getElementById('myDropdown');

    dropdownButton.addEventListener('click', toggleDropdown);

    /* When the user clicks on the button, 
    toggle between hiding and showing the dropdown content */
    function toggleDropdown(event) {
        dropdownDiv.classList.toggle('show');
        event.stopPropagation(); // Prevent click from causing the window click handler to close the dropdown
    }

    // Close the dropdown if the user clicks outside of it
    window.onclick = function(event) {
        const isClickedOutsideDropdownDiv = !dropdownDiv.contains(event.target);

        if (isClickedOutsideDropdownDiv) {
            dropdownDiv.classList.remove('show');
        }
    }

    // Close the dropdown if the user presses Escape
    document.addEventListener('keydown', function(event) {
        if (event.key === 'Escape') {
            dropdownDiv.classList.remove('show');
        }
    });

    // Set the state of the timestamp checkbox
    document.getElementById('timestamps').checked = document.querySelector('table.console').classList.contains('timestamps');
    document.getElementById('timestamps').addEventListener('change', function() {
        if(this.checked) {
            document.querySelector('table.console').classList.add('timestamps');
        } else {
            document.querySelector('table.console').classList.remove('timestamps');
        }
    });

    // Set up hide irrelevant events checkbox state and event listener
    document.getElementById('hideIrrelevantEvents').addEventListener('change', function() {
        // When checkbox state changes, only update button visibility, not availability
        updateButtonVisibility();
    });

    //------------------- drop down functionality end -------------------



    // Convert a date to a string in the format HH:MM:SS.sss
    function formatTime(date) {
        return date.getHours().toString().padStart(2, '0') + ':' +
            date.getMinutes().toString().padStart(2, '0') + ':' +
            date.getSeconds().toString().padStart(2, '0') + '.' +
            date.getMilliseconds().toString().padStart(3, '0');
    }

    // Add a row to the history table.
    function addHistoryRow(time, event, html = false) {
        var row = document.createElement('tr');
        var timeCell = document.createElement('td');
        timeCell.innerText = formatTime(time);
        timeCell.classList.add('timestamp');
        var eventCell = document.createElement('td');

        if(html) {
            eventCell.innerHTML = event;
        } else {
            eventCell.innerText = event;
        }

        row.appendChild(timeCell);
        row.appendChild(eventCell);
        document.querySelector('tbody').appendChild(row);
    }

    var sm = new IntentState();

    // prompt the user to evaluate guards manually
    sm.evaluateGuard = (vertexName, behaviorUml) => {
        return confirm(`Evaluate guard for\n${vertexName} behavior:\n${behaviorUml}.\n\nPress 'OK' to evaluate guard as true and 'Cancel' to evaluate it as false.`);
    };

    const highlightedEdges = new Set();
    function highlightEdge(edgeId) {
        var edge = document.getElementById(edgeId);
        if (edge) {
            edge.classList.add('active');
            highlightedEdges.add(edge);
        }
    }

    function clearHighlightedEdges() {
        for (const edge of highlightedEdges) {
            edge.classList.remove('active');
            const showOldTraversal = false;
            if (showOldTraversal) {
                // shows that the edge was traversed. Optional, but kinda nice.
                edge.style.stroke = 'green';
            }
        }
        highlightedEdges.clear();
    }

    // Function to update event button states (availability and visibility)
    function updateEventButtonStates(currentStateName) {
        const availableEvents = stateEventsMapping[currentStateName] || [];

        diagramEventNamesArray.forEach(eventName => {
            const button = document.getElementById('button_' + eventName);
            if (button) {
                const isAvailable = availableEvents.includes(eventName);

                // Only set disabled property, CSS :disabled pseudo-class handles styling
                button.disabled = !isAvailable;
            }
        });

        // Update visibility based on checkbox state
        updateButtonVisibility();
    }

    // Function to update button visibility based on Hide Unused checkbox
    function updateButtonVisibility() {
        const hideIrrelevantEvents = document.getElementById('hideIrrelevantEvents').checked;

        diagramEventNamesArray.forEach(eventName => {
            const button = document.getElementById('button_' + eventName);
            if (button) {
                // Toggle hidden class based on checkbox state and button disabled state
                button.classList.toggle('hidden', hideIrrelevantEvents && button.disabled);
            }
        });
    }

    // The simulator uses a tracer callback to perform operations such as 
    // state highlighting and logging. You do not need this functionality
    // when using IntentState.js in your own applications, although you may
    // choose to implement a tracer for debugging purposes.
    sm.tracer = {
        enterState: (mermaidName) => {
            var e = document.querySelector('g[data-id=' + mermaidName + ']');
            if(e) {
                e.classList.add('active');
                panOnScreen(e);
            }
            sm.tracer.log('➡️ Entered ' + mermaidName);

            // Update event button states
            updateEventButtonStates(mermaidName);
        },
        exitState: (mermaidName) => {
            document.querySelector('g[data-id=' + mermaidName + ']')?.classList.remove('active');
        },
        edgeTransition: (edgeId) => {
            highlightEdge(edgeId);
        },
        log: (message, html=false) => {
            addHistoryRow(new Date(), message, html);
        }
    };

    // Wire up the buttons that dispatch events for the state machine.
    diagramEventNamesArray.forEach(diagramEventName => {
        var button = document.createElement('button');
        button.id = 'button_' + diagramEventName;
        button.className = 'event-button';
        button.innerText = diagramEventName;
        button.addEventListener('click', () => {
            // Only handle click events when button is enabled
            if (!button.disabled) {
                clearHighlightedEdges();
                sm.tracer?.log('<span class="dispatched"><span class="trigger">' + diagramEventName + '</span> DISPATCHED</span>', true);
                const fsmEventName = diagramEventName.toUpperCase();
                sm.dispatchEvent(IntentState.EventId[fsmEventName]);
            }
        });
        document.getElementById('buttons').appendChild(button);
    });

    sm.tracer?.log('<span class="dispatched">START</span>', true);
    sm.start(); // This will cause `updateEventButtonStates()` to be called.

    function panOnScreen(element) {
        if(!element) return;

        var bounds = element.getBoundingClientRect();
        if(bounds.x<0 || bounds.y<0) {
            var x = Math.max(0, -bounds.x + 20);
            var y = Math.max(0, -bounds.y + 20);
            window.panZoom.panBy({x: x, y: y});
        }
        var panebounds = document.querySelector('svg').getBoundingClientRect();
        if(bounds.x>panebounds.width || bounds.y>panebounds.height) {
            var x = Math.min(0, panebounds.width - bounds.x - bounds.width - 20);
            var y = Math.min(0, panebounds.height - bounds.y - bounds.height - 20);
            window.panZoom.panBy({x: x, y: y});
        }
    }
</script>


</body>
</html>
