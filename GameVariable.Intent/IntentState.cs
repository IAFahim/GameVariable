// Autogenerated with StateSmith 0.19.0-alpha-1+5931a3a68e50c80e83349118a90569bf08270686.
// Algorithm: Balanced2. See https://github.com/StateSmith/StateSmith/wiki/Algorithms
// Generated state machine

namespace GameVariable.Intent;

/// <summary>
///     The main struct definition for the IntentState state machine.
///     For full documentation, see IntentState.Docs.cs.
/// </summary>
public partial struct IntentState : IIntent<IntentState.StateId, IntentState.EventId>
{
    /// <summary>
    /// Represents events that can trigger state transitions in the intent state machine.
    /// </summary>
    public enum EventId : byte
    {
        /// <summary>Triggered when the intent is activated.</summary>
        ACTIVATED = 0,
        /// <summary>Triggered when all child intents have completed.</summary>
        ALL_CHILDREN_COMPLETED = 1,
        /// <summary>Triggered to cancel the intent.</summary>
        CANCEL = 2,
        /// <summary>Triggered when a child task is created.</summary>
        CHILD_TASK_CREATED = 3,
        /// <summary>Triggered when the intent completes successfully.</summary>
        COMPLETED_SUCCESSFULLY = 4,
        /// <summary>Triggered when the intent is preparing to run.</summary>
        GET_READY = 5,
        /// <summary>Triggered when recovering from a faulted state.</summary>
        RECOVER_RETRY = 6,
        /// <summary>Triggered when the intent should run again.</summary>
        RUN_AGAIN = 7,
        /// <summary>Triggered to start running the intent.</summary>
        START_RUNNING = 8,
        /// <summary>Triggered when the intent is unable to complete.</summary>
        UNABLE_TO_COMPLETE = 9,
        /// <summary>Triggered when recovery from a fault fails.</summary>
        UNABLE_TO_RECOVER = 10,
    }

    /// <summary>
    /// The total number of event types supported by the state machine.
    /// </summary>
    public const int EventIdCount = 11;

    /// <summary>
    /// Represents the possible states of the intent state machine.
    /// </summary>
    public enum StateId : byte
    {
        /// <summary>The root state of the state machine.</summary>
        ROOT = 0,
        /// <summary>The intent has been canceled.</summary>
        CANCELED = 1,
        /// <summary>The intent has been created but not yet started.</summary>
        CREATED = 2,
        /// <summary>The intent has encountered a fault.</summary>
        FAULTED = 3,
        /// <summary>The intent has run to completion.</summary>
        RAN_TO_COMPLETION = 4,
        /// <summary>The intent is currently running.</summary>
        RUNNING = 5,
        /// <summary>The intent is waiting for activation.</summary>
        WAITING_FOR_ACTIVATION = 6,
        /// <summary>The intent is waiting for child intents to complete.</summary>
        WAITING_FOR_CHILDREN_TO_COMPLETE = 7,
        /// <summary>The intent is waiting to start running.</summary>
        WAITING_TO_RUN = 8,
    }

    /// <summary>
    /// The total number of states supported by the state machine.
    /// </summary>
    public const int StateIdCount = 9;

    /// <summary>
    /// Used internally by state machine. Feel free to inspect, but don't modify.
    /// </summary>
    public StateId stateId;

    /// <summary>
    /// State machine constructor. Must be called before start or dispatch event functions. Not thread safe.
    /// </summary>
    public IntentState()
    {
    }

    /// <summary>
    /// Starts the state machine. Must be called before dispatching events. Not thread safe.
    /// </summary>
    public void Start()
    {
        ROOT_enter();
        // ROOT behavior
        // uml: TransitionTo(ROOT.<InitialState>)
        {
            // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition). Already at LCA, no exiting required.

            // Step 2: Transition action: ``.

            // Step 3: Enter/move towards transition target `ROOT.<InitialState>`.
            // ROOT.<InitialState> is a pseudo state and cannot have an `enter` trigger.

            // ROOT.<InitialState> behavior
            // uml: TransitionTo(CREATED)
            {
                // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition). Already at LCA, no exiting required.

                // Step 2: Transition action: ``.

                // Step 3: Enter/move towards transition target `CREATED`.
                CREATED_enter();

                // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
                return;
            } // end of behavior for ROOT.<InitialState>
        } // end of behavior for ROOT
    }

    /// <summary>
    /// Dispatches an event to the state machine. Not thread safe.
    /// </summary>
    /// <param name="eventId">The event to dispatch. Note! This function assumes that the parameter is valid.</param>
    public void DispatchEvent(EventId eventId)
    {
        switch (this.stateId)
        {
            // STATE: IntentState
            case StateId.ROOT:
                // No events handled by this state (or its ancestors).
                break;

            // STATE: CANCELED
            case StateId.CANCELED:
                // No events handled by this state (or its ancestors).
                break;

            // STATE: CREATED
            case StateId.CREATED:
                switch (eventId)
                {
                    case EventId.ACTIVATED: CREATED_activated(); break;
                    case EventId.GET_READY: CREATED_get_ready(); break;
                    case EventId.CANCEL: CREATED_cancel(); break;
                }

                break;

            // STATE: FAULTED
            case StateId.FAULTED:
                switch (eventId)
                {
                    case EventId.RECOVER_RETRY: FAULTED_recover_retry(); break;
                    case EventId.UNABLE_TO_RECOVER: FAULTED_unable_to_recover(); break;
                }

                break;

            // STATE: RAN_TO_COMPLETION
            case StateId.RAN_TO_COMPLETION:
                switch (eventId)
                {
                    case EventId.RUN_AGAIN: RAN_TO_COMPLETION_run_again(); break;
                }

                break;

            // STATE: RUNNING
            case StateId.RUNNING:
                switch (eventId)
                {
                    case EventId.COMPLETED_SUCCESSFULLY: RUNNING_completed_successfully(); break;
                    case EventId.CHILD_TASK_CREATED: RUNNING_child_task_created(); break;
                    case EventId.UNABLE_TO_COMPLETE: RUNNING_unable_to_complete(); break;
                    case EventId.CANCEL: RUNNING_cancel(); break;
                }

                break;

            // STATE: WAITING_FOR_ACTIVATION
            case StateId.WAITING_FOR_ACTIVATION:
                switch (eventId)
                {
                    case EventId.ACTIVATED: WAITING_FOR_ACTIVATION_activated(); break;
                    case EventId.CANCEL: WAITING_FOR_ACTIVATION_cancel(); break;
                }

                break;

            // STATE: WAITING_FOR_CHILDREN_TO_COMPLETE
            case StateId.WAITING_FOR_CHILDREN_TO_COMPLETE:
                switch (eventId)
                {
                    case EventId.ALL_CHILDREN_COMPLETED:
                        WAITING_FOR_CHILDREN_TO_COMPLETE_all_children_completed(); break;
                    case EventId.UNABLE_TO_RECOVER: WAITING_FOR_CHILDREN_TO_COMPLETE_unable_to_recover(); break;
                    case EventId.CANCEL: WAITING_FOR_CHILDREN_TO_COMPLETE_cancel(); break;
                }

                break;

            // STATE: WAITING_TO_RUN
            case StateId.WAITING_TO_RUN:
                switch (eventId)
                {
                    case EventId.START_RUNNING: WAITING_TO_RUN_start_running(); break;
                    case EventId.CANCEL: WAITING_TO_RUN_cancel(); break;
                }

                break;
        }
    }

    // This function is used when StateSmith doesn't know what the active leaf state is at
    // compile time due to sub states or when multiple states need to be exited.
    private void ExitUpToStateHandler(StateId desiredState)
    {
        while (this.stateId != desiredState)
        {
            switch (this.stateId)
            {
                case StateId.CANCELED: CANCELED_exit(); break;

                case StateId.CREATED: CREATED_exit(); break;

                case StateId.FAULTED: FAULTED_exit(); break;

                case StateId.RAN_TO_COMPLETION: RAN_TO_COMPLETION_exit(); break;

                case StateId.RUNNING: RUNNING_exit(); break;

                case StateId.WAITING_FOR_ACTIVATION: WAITING_FOR_ACTIVATION_exit(); break;

                case StateId.WAITING_FOR_CHILDREN_TO_COMPLETE: WAITING_FOR_CHILDREN_TO_COMPLETE_exit(); break;

                case StateId.WAITING_TO_RUN: WAITING_TO_RUN_exit(); break;

                default: return; // Just to be safe. Prevents infinite loop if state ID memory is somehow corrupted.
            }
        }
    }


    ////////////////////////////////////////////////////////////////////////////////
    // event handlers for state ROOT
    ////////////////////////////////////////////////////////////////////////////////

    private void ROOT_enter()
    {
        this.stateId = StateId.ROOT;
    }


    ////////////////////////////////////////////////////////////////////////////////
    // event handlers for state CANCELED
    ////////////////////////////////////////////////////////////////////////////////

    private void CANCELED_enter()
    {
        this.stateId = StateId.CANCELED;
    }

    private void CANCELED_exit()
    {
        this.stateId = StateId.ROOT;
    }


    ////////////////////////////////////////////////////////////////////////////////
    // event handlers for state CREATED
    ////////////////////////////////////////////////////////////////////////////////

    private void CREATED_enter()
    {
        this.stateId = StateId.CREATED;
    }

    private void CREATED_exit()
    {
        this.stateId = StateId.ROOT;
    }

    private void CREATED_activated()
    {
        // CREATED behavior
        // uml: ACTIVATED TransitionTo(WAITING_TO_RUN)
        {
            // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition).
            CREATED_exit();

            // Step 2: Transition action: ``.

            // Step 3: Enter/move towards transition target `WAITING_TO_RUN`.
            WAITING_TO_RUN_enter();

            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for CREATED

        // No ancestor handles this event.
    }

    private void CREATED_cancel()
    {
        // CREATED behavior
        // uml: CANCEL TransitionTo(CANCELED)
        {
            // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition).
            CREATED_exit();

            // Step 2: Transition action: ``.

            // Step 3: Enter/move towards transition target `CANCELED`.
            CANCELED_enter();

            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for CREATED

        // No ancestor handles this event.
    }

    private void CREATED_get_ready()
    {
        // CREATED behavior
        // uml: GET_READY TransitionTo(WAITING_FOR_ACTIVATION)
        {
            // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition).
            CREATED_exit();

            // Step 2: Transition action: ``.

            // Step 3: Enter/move towards transition target `WAITING_FOR_ACTIVATION`.
            WAITING_FOR_ACTIVATION_enter();

            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for CREATED

        // No ancestor handles this event.
    }


    ////////////////////////////////////////////////////////////////////////////////
    // event handlers for state FAULTED
    ////////////////////////////////////////////////////////////////////////////////

    private void FAULTED_enter()
    {
        this.stateId = StateId.FAULTED;
    }

    private void FAULTED_exit()
    {
        this.stateId = StateId.ROOT;
    }

    private void FAULTED_recover_retry()
    {
        // FAULTED behavior
        // uml: RECOVER_RETRY TransitionTo(WAITING_TO_RUN)
        {
            // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition).
            FAULTED_exit();

            // Step 2: Transition action: ``.

            // Step 3: Enter/move towards transition target `WAITING_TO_RUN`.
            WAITING_TO_RUN_enter();

            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for FAULTED

        // No ancestor handles this event.
    }

    private void FAULTED_unable_to_recover()
    {
        // FAULTED behavior
        // uml: UNABLE_TO_RECOVER TransitionTo(CANCELED)
        {
            // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition).
            FAULTED_exit();

            // Step 2: Transition action: ``.

            // Step 3: Enter/move towards transition target `CANCELED`.
            CANCELED_enter();

            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for FAULTED

        // No ancestor handles this event.
    }


    ////////////////////////////////////////////////////////////////////////////////
    // event handlers for state RAN_TO_COMPLETION
    ////////////////////////////////////////////////////////////////////////////////

    private void RAN_TO_COMPLETION_enter()
    {
        this.stateId = StateId.RAN_TO_COMPLETION;
    }

    private void RAN_TO_COMPLETION_exit()
    {
        this.stateId = StateId.ROOT;
    }

    private void RAN_TO_COMPLETION_run_again()
    {
        // RAN_TO_COMPLETION behavior
        // uml: RUN_AGAIN TransitionTo(WAITING_TO_RUN)
        {
            // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition).
            RAN_TO_COMPLETION_exit();

            // Step 2: Transition action: ``.

            // Step 3: Enter/move towards transition target `WAITING_TO_RUN`.
            WAITING_TO_RUN_enter();

            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for RAN_TO_COMPLETION

        // No ancestor handles this event.
    }


    ////////////////////////////////////////////////////////////////////////////////
    // event handlers for state RUNNING
    ////////////////////////////////////////////////////////////////////////////////

    private void RUNNING_enter()
    {
        this.stateId = StateId.RUNNING;
    }

    private void RUNNING_exit()
    {
        this.stateId = StateId.ROOT;
    }

    private void RUNNING_cancel()
    {
        // RUNNING behavior
        // uml: CANCEL TransitionTo(CANCELED)
        {
            // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition).
            RUNNING_exit();

            // Step 2: Transition action: ``.

            // Step 3: Enter/move towards transition target `CANCELED`.
            CANCELED_enter();

            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for RUNNING

        // No ancestor handles this event.
    }

    private void RUNNING_child_task_created()
    {
        // RUNNING behavior
        // uml: CHILD_TASK_CREATED TransitionTo(WAITING_FOR_CHILDREN_TO_COMPLETE)
        {
            // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition).
            RUNNING_exit();

            // Step 2: Transition action: ``.

            // Step 3: Enter/move towards transition target `WAITING_FOR_CHILDREN_TO_COMPLETE`.
            WAITING_FOR_CHILDREN_TO_COMPLETE_enter();

            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for RUNNING

        // No ancestor handles this event.
    }

    private void RUNNING_completed_successfully()
    {
        // RUNNING behavior
        // uml: COMPLETED_SUCCESSFULLY TransitionTo(RAN_TO_COMPLETION)
        {
            // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition).
            RUNNING_exit();

            // Step 2: Transition action: ``.

            // Step 3: Enter/move towards transition target `RAN_TO_COMPLETION`.
            RAN_TO_COMPLETION_enter();

            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for RUNNING

        // No ancestor handles this event.
    }

    private void RUNNING_unable_to_complete()
    {
        // RUNNING behavior
        // uml: UNABLE_TO_COMPLETE TransitionTo(FAULTED)
        {
            // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition).
            RUNNING_exit();

            // Step 2: Transition action: ``.

            // Step 3: Enter/move towards transition target `FAULTED`.
            FAULTED_enter();

            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for RUNNING

        // No ancestor handles this event.
    }


    ////////////////////////////////////////////////////////////////////////////////
    // event handlers for state WAITING_FOR_ACTIVATION
    ////////////////////////////////////////////////////////////////////////////////

    private void WAITING_FOR_ACTIVATION_enter()
    {
        this.stateId = StateId.WAITING_FOR_ACTIVATION;
    }

    private void WAITING_FOR_ACTIVATION_exit()
    {
        this.stateId = StateId.ROOT;
    }

    private void WAITING_FOR_ACTIVATION_activated()
    {
        // WAITING_FOR_ACTIVATION behavior
        // uml: ACTIVATED TransitionTo(WAITING_TO_RUN)
        {
            // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition).
            WAITING_FOR_ACTIVATION_exit();

            // Step 2: Transition action: ``.

            // Step 3: Enter/move towards transition target `WAITING_TO_RUN`.
            WAITING_TO_RUN_enter();

            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for WAITING_FOR_ACTIVATION

        // No ancestor handles this event.
    }

    private void WAITING_FOR_ACTIVATION_cancel()
    {
        // WAITING_FOR_ACTIVATION behavior
        // uml: CANCEL TransitionTo(CANCELED)
        {
            // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition).
            WAITING_FOR_ACTIVATION_exit();

            // Step 2: Transition action: ``.

            // Step 3: Enter/move towards transition target `CANCELED`.
            CANCELED_enter();

            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for WAITING_FOR_ACTIVATION

        // No ancestor handles this event.
    }


    ////////////////////////////////////////////////////////////////////////////////
    // event handlers for state WAITING_FOR_CHILDREN_TO_COMPLETE
    ////////////////////////////////////////////////////////////////////////////////

    private void WAITING_FOR_CHILDREN_TO_COMPLETE_enter()
    {
        this.stateId = StateId.WAITING_FOR_CHILDREN_TO_COMPLETE;
    }

    private void WAITING_FOR_CHILDREN_TO_COMPLETE_exit()
    {
        this.stateId = StateId.ROOT;
    }

    private void WAITING_FOR_CHILDREN_TO_COMPLETE_all_children_completed()
    {
        // WAITING_FOR_CHILDREN_TO_COMPLETE behavior
        // uml: ALL_CHILDREN_COMPLETED TransitionTo(RUNNING)
        {
            // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition).
            WAITING_FOR_CHILDREN_TO_COMPLETE_exit();

            // Step 2: Transition action: ``.

            // Step 3: Enter/move towards transition target `RUNNING`.
            RUNNING_enter();

            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for WAITING_FOR_CHILDREN_TO_COMPLETE

        // No ancestor handles this event.
    }

    private void WAITING_FOR_CHILDREN_TO_COMPLETE_cancel()
    {
        // WAITING_FOR_CHILDREN_TO_COMPLETE behavior
        // uml: CANCEL TransitionTo(CANCELED)
        {
            // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition).
            WAITING_FOR_CHILDREN_TO_COMPLETE_exit();

            // Step 2: Transition action: ``.

            // Step 3: Enter/move towards transition target `CANCELED`.
            CANCELED_enter();

            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for WAITING_FOR_CHILDREN_TO_COMPLETE

        // No ancestor handles this event.
    }

    private void WAITING_FOR_CHILDREN_TO_COMPLETE_unable_to_recover()
    {
        // WAITING_FOR_CHILDREN_TO_COMPLETE behavior
        // uml: UNABLE_TO_RECOVER TransitionTo(FAULTED)
        {
            // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition).
            WAITING_FOR_CHILDREN_TO_COMPLETE_exit();

            // Step 2: Transition action: ``.

            // Step 3: Enter/move towards transition target `FAULTED`.
            FAULTED_enter();

            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for WAITING_FOR_CHILDREN_TO_COMPLETE

        // No ancestor handles this event.
    }


    ////////////////////////////////////////////////////////////////////////////////
    // event handlers for state WAITING_TO_RUN
    ////////////////////////////////////////////////////////////////////////////////

    private void WAITING_TO_RUN_enter()
    {
        this.stateId = StateId.WAITING_TO_RUN;
    }

    private void WAITING_TO_RUN_exit()
    {
        this.stateId = StateId.ROOT;
    }

    private void WAITING_TO_RUN_cancel()
    {
        // WAITING_TO_RUN behavior
        // uml: CANCEL TransitionTo(CANCELED)
        {
            // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition).
            WAITING_TO_RUN_exit();

            // Step 2: Transition action: ``.

            // Step 3: Enter/move towards transition target `CANCELED`.
            CANCELED_enter();

            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for WAITING_TO_RUN

        // No ancestor handles this event.
    }

    private void WAITING_TO_RUN_start_running()
    {
        // WAITING_TO_RUN behavior
        // uml: START_RUNNING TransitionTo(RUNNING)
        {
            // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition).
            WAITING_TO_RUN_exit();

            // Step 2: Transition action: ``.

            // Step 3: Enter/move towards transition target `RUNNING`.
            RUNNING_enter();

            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for WAITING_TO_RUN

        // No ancestor handles this event.
    }

    /// <summary>
    /// Converts a state identifier to its string representation. Thread safe.
    /// </summary>
    /// <param name="id">The state identifier to convert.</param>
    /// <returns>The string representation of the state.</returns>
    public string StateIdToString(StateId id)
    {
        switch (id)
        {
            case StateId.ROOT: return "ROOT";
            case StateId.CANCELED: return "CANCELED";
            case StateId.CREATED: return "CREATED";
            case StateId.FAULTED: return "FAULTED";
            case StateId.RAN_TO_COMPLETION: return "RAN_TO_COMPLETION";
            case StateId.RUNNING: return "RUNNING";
            case StateId.WAITING_FOR_ACTIVATION: return "WAITING_FOR_ACTIVATION";
            case StateId.WAITING_FOR_CHILDREN_TO_COMPLETE: return "WAITING_FOR_CHILDREN_TO_COMPLETE";
            case StateId.WAITING_TO_RUN: return "WAITING_TO_RUN";
            default: return "?";
        }
    }

    /// <summary>
    /// Converts an event identifier to its string representation. Thread safe.
    /// </summary>
    /// <param name="id">The event identifier to convert.</param>
    /// <returns>The string representation of the event.</returns>
    public string EventIdToString(EventId id)
    {
        switch (id)
        {
            case EventId.ACTIVATED: return "ACTIVATED";
            case EventId.ALL_CHILDREN_COMPLETED: return "ALL_CHILDREN_COMPLETED";
            case EventId.CANCEL: return "CANCEL";
            case EventId.CHILD_TASK_CREATED: return "CHILD_TASK_CREATED";
            case EventId.COMPLETED_SUCCESSFULLY: return "COMPLETED_SUCCESSFULLY";
            case EventId.GET_READY: return "GET_READY";
            case EventId.RECOVER_RETRY: return "RECOVER_RETRY";
            case EventId.RUN_AGAIN: return "RUN_AGAIN";
            case EventId.START_RUNNING: return "START_RUNNING";
            case EventId.UNABLE_TO_COMPLETE: return "UNABLE_TO_COMPLETE";
            case EventId.UNABLE_TO_RECOVER: return "UNABLE_TO_RECOVER";
            default: return "?";
        }
    }
}